// Code generated by numeric_vec_typemap.gen_test.go.tmpl. DO NOT EDIT.
package data_test

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/factset/go-drill/internal/data"
	"github.com/factset/go-drill/internal/rpc/proto/common"
	"github.com/factset/go-drill/internal/rpc/proto/exec/shared"
	"google.golang.org/protobuf/proto"
)

func TestNewNumericVecRequiredInt64(t *testing.T) {
	const N = 10
	b := data.Int64Traits.CastToBytes([]int64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := &shared.SerializedField{
		MajorType: &common.MajorType{
			MinorType: common.MinorType_BIGINT.Enum(),
			Mode:      common.DataMode_REQUIRED.Enum(),
		},
	}

	dv := data.NewValueVec(b, meta)
	assert.IsType(t, (*data.Int64Vector)(nil), dv)
}

func TestNewNumericVecOptionalInt64(t *testing.T) {
	const N = 10
	b := data.Int64Traits.CastToBytes([]int64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}

	meta := &shared.SerializedField{
		ValueCount: proto.Int32(0),
		MajorType: &common.MajorType{
			MinorType: common.MinorType_BIGINT.Enum(),
			Mode:      common.DataMode_OPTIONAL.Enum(),
		},
	}

	dv := data.NewValueVec(append(bytemap, b...), meta)
	assert.IsType(t, (*data.NullableInt64Vector)(nil), dv)
}

func TestNewNumericVecRequiredInt32(t *testing.T) {
	const N = 10
	b := data.Int32Traits.CastToBytes([]int32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := &shared.SerializedField{
		MajorType: &common.MajorType{
			MinorType: common.MinorType_INT.Enum(),
			Mode:      common.DataMode_REQUIRED.Enum(),
		},
	}

	dv := data.NewValueVec(b, meta)
	assert.IsType(t, (*data.Int32Vector)(nil), dv)
}

func TestNewNumericVecOptionalInt32(t *testing.T) {
	const N = 10
	b := data.Int32Traits.CastToBytes([]int32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}

	meta := &shared.SerializedField{
		ValueCount: proto.Int32(0),
		MajorType: &common.MajorType{
			MinorType: common.MinorType_INT.Enum(),
			Mode:      common.DataMode_OPTIONAL.Enum(),
		},
	}

	dv := data.NewValueVec(append(bytemap, b...), meta)
	assert.IsType(t, (*data.NullableInt32Vector)(nil), dv)
}

func TestNewNumericVecRequiredFloat64(t *testing.T) {
	const N = 10
	b := data.Float64Traits.CastToBytes([]float64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := &shared.SerializedField{
		MajorType: &common.MajorType{
			MinorType: common.MinorType_FLOAT8.Enum(),
			Mode:      common.DataMode_REQUIRED.Enum(),
		},
	}

	dv := data.NewValueVec(b, meta)
	assert.IsType(t, (*data.Float64Vector)(nil), dv)
}

func TestNewNumericVecOptionalFloat64(t *testing.T) {
	const N = 10
	b := data.Float64Traits.CastToBytes([]float64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}

	meta := &shared.SerializedField{
		ValueCount: proto.Int32(0),
		MajorType: &common.MajorType{
			MinorType: common.MinorType_FLOAT8.Enum(),
			Mode:      common.DataMode_OPTIONAL.Enum(),
		},
	}

	dv := data.NewValueVec(append(bytemap, b...), meta)
	assert.IsType(t, (*data.NullableFloat64Vector)(nil), dv)
}

func TestNewNumericVecRequiredFloat32(t *testing.T) {
	const N = 10
	b := data.Float32Traits.CastToBytes([]float32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := &shared.SerializedField{
		MajorType: &common.MajorType{
			MinorType: common.MinorType_FLOAT4.Enum(),
			Mode:      common.DataMode_REQUIRED.Enum(),
		},
	}

	dv := data.NewValueVec(b, meta)
	assert.IsType(t, (*data.Float32Vector)(nil), dv)
}

func TestNewNumericVecOptionalFloat32(t *testing.T) {
	const N = 10
	b := data.Float32Traits.CastToBytes([]float32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}

	meta := &shared.SerializedField{
		ValueCount: proto.Int32(0),
		MajorType: &common.MajorType{
			MinorType: common.MinorType_FLOAT4.Enum(),
			Mode:      common.DataMode_OPTIONAL.Enum(),
		},
	}

	dv := data.NewValueVec(append(bytemap, b...), meta)
	assert.IsType(t, (*data.NullableFloat32Vector)(nil), dv)
}

func TestNewNumericVecRequiredInt16(t *testing.T) {
	const N = 10
	b := data.Int16Traits.CastToBytes([]int16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := &shared.SerializedField{
		MajorType: &common.MajorType{
			MinorType: common.MinorType_SMALLINT.Enum(),
			Mode:      common.DataMode_REQUIRED.Enum(),
		},
	}

	dv := data.NewValueVec(b, meta)
	assert.IsType(t, (*data.Int16Vector)(nil), dv)
}

func TestNewNumericVecOptionalInt16(t *testing.T) {
	const N = 10
	b := data.Int16Traits.CastToBytes([]int16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}

	meta := &shared.SerializedField{
		ValueCount: proto.Int32(0),
		MajorType: &common.MajorType{
			MinorType: common.MinorType_SMALLINT.Enum(),
			Mode:      common.DataMode_OPTIONAL.Enum(),
		},
	}

	dv := data.NewValueVec(append(bytemap, b...), meta)
	assert.IsType(t, (*data.NullableInt16Vector)(nil), dv)
}

func TestNewNumericVecRequiredInt8(t *testing.T) {
	const N = 10
	b := data.Int8Traits.CastToBytes([]int8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := &shared.SerializedField{
		MajorType: &common.MajorType{
			MinorType: common.MinorType_TINYINT.Enum(),
			Mode:      common.DataMode_REQUIRED.Enum(),
		},
	}

	dv := data.NewValueVec(b, meta)
	assert.IsType(t, (*data.Int8Vector)(nil), dv)
}

func TestNewNumericVecOptionalInt8(t *testing.T) {
	const N = 10
	b := data.Int8Traits.CastToBytes([]int8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}

	meta := &shared.SerializedField{
		ValueCount: proto.Int32(0),
		MajorType: &common.MajorType{
			MinorType: common.MinorType_TINYINT.Enum(),
			Mode:      common.DataMode_OPTIONAL.Enum(),
		},
	}

	dv := data.NewValueVec(append(bytemap, b...), meta)
	assert.IsType(t, (*data.NullableInt8Vector)(nil), dv)
}
