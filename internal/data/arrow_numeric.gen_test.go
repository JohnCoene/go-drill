// Code generated by arrow_numeric.gen_test.go.tmpl. DO NOT EDIT.
package data_test

import (
	"testing"

	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/array"
	"github.com/factset/go-drill/internal/data"
	"github.com/factset/go-drill/internal/rpc/proto/common"
	"github.com/stretchr/testify/assert"
)

func TestInt64Arrow(t *testing.T) {
	const N = 10
	b := data.Int64Traits.CastToBytes([]int64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_BIGINT.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Int64, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, int64(i), arr.(*array.Int64).Value(i))
	}
}

func TestOptionalInt64Arrow(t *testing.T) {
	const N = 10
	b := data.Int64Traits.CastToBytes([]int64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_BIGINT.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Int64, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, int64(i), arr.(*array.Int64).Value(i))
		}
	}
}

func TestInt32Arrow(t *testing.T) {
	const N = 10
	b := data.Int32Traits.CastToBytes([]int32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_INT.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Int32, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, int32(i), arr.(*array.Int32).Value(i))
	}
}

func TestOptionalInt32Arrow(t *testing.T) {
	const N = 10
	b := data.Int32Traits.CastToBytes([]int32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_INT.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Int32, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, int32(i), arr.(*array.Int32).Value(i))
		}
	}
}

func TestFloat64Arrow(t *testing.T) {
	const N = 10
	b := data.Float64Traits.CastToBytes([]float64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_FLOAT8.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Float64, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, float64(i), arr.(*array.Float64).Value(i))
	}
}

func TestOptionalFloat64Arrow(t *testing.T) {
	const N = 10
	b := data.Float64Traits.CastToBytes([]float64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_FLOAT8.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Float64, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, float64(i), arr.(*array.Float64).Value(i))
		}
	}
}

func TestUint64Arrow(t *testing.T) {
	const N = 10
	b := data.Uint64Traits.CastToBytes([]uint64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_UINT8.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Uint64, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, uint64(i), arr.(*array.Uint64).Value(i))
	}
}

func TestOptionalUint64Arrow(t *testing.T) {
	const N = 10
	b := data.Uint64Traits.CastToBytes([]uint64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_UINT8.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Uint64, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, uint64(i), arr.(*array.Uint64).Value(i))
		}
	}
}

func TestUint32Arrow(t *testing.T) {
	const N = 10
	b := data.Uint32Traits.CastToBytes([]uint32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_UINT4.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Uint32, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, uint32(i), arr.(*array.Uint32).Value(i))
	}
}

func TestOptionalUint32Arrow(t *testing.T) {
	const N = 10
	b := data.Uint32Traits.CastToBytes([]uint32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_UINT4.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Uint32, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, uint32(i), arr.(*array.Uint32).Value(i))
		}
	}
}

func TestFloat32Arrow(t *testing.T) {
	const N = 10
	b := data.Float32Traits.CastToBytes([]float32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_FLOAT4.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Float32, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, float32(i), arr.(*array.Float32).Value(i))
	}
}

func TestOptionalFloat32Arrow(t *testing.T) {
	const N = 10
	b := data.Float32Traits.CastToBytes([]float32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_FLOAT4.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Float32, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, float32(i), arr.(*array.Float32).Value(i))
		}
	}
}

func TestInt16Arrow(t *testing.T) {
	const N = 10
	b := data.Int16Traits.CastToBytes([]int16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_SMALLINT.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Int16, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, int16(i), arr.(*array.Int16).Value(i))
	}
}

func TestOptionalInt16Arrow(t *testing.T) {
	const N = 10
	b := data.Int16Traits.CastToBytes([]int16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_SMALLINT.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Int16, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, int16(i), arr.(*array.Int16).Value(i))
		}
	}
}

func TestUint16Arrow(t *testing.T) {
	const N = 10
	b := data.Uint16Traits.CastToBytes([]uint16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_UINT2.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Uint16, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, uint16(i), arr.(*array.Uint16).Value(i))
	}
}

func TestOptionalUint16Arrow(t *testing.T) {
	const N = 10
	b := data.Uint16Traits.CastToBytes([]uint16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_UINT2.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Uint16, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, uint16(i), arr.(*array.Uint16).Value(i))
		}
	}
}

func TestInt8Arrow(t *testing.T) {
	const N = 10
	b := data.Int8Traits.CastToBytes([]int8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_TINYINT.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Int8, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, int8(i), arr.(*array.Int8).Value(i))
	}
}

func TestOptionalInt8Arrow(t *testing.T) {
	const N = 10
	b := data.Int8Traits.CastToBytes([]int8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_TINYINT.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Int8, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, int8(i), arr.(*array.Int8).Value(i))
		}
	}
}

func TestUint8Arrow(t *testing.T) {
	const N = 10
	b := data.Uint8Traits.CastToBytes([]uint8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	meta := createMetaField(common.DataMode_REQUIRED, common.MinorType_UINT1.Enum(), int32(N), int32(len(b)))

	arr := data.NewArrowArray(b, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Uint8, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Zero(t, arr.NullN())

	for i := 0; i < N; i++ {
		assert.True(t, arr.IsValid(i))
		assert.Equal(t, uint8(i), arr.(*array.Uint8).Value(i))
	}
}

func TestOptionalUint8Arrow(t *testing.T) {
	const N = 10
	b := data.Uint8Traits.CastToBytes([]uint8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := createMetaField(common.DataMode_OPTIONAL, common.MinorType_UINT1.Enum(), int32(N), int32(len(b)))

	rawData := append(bytemap, b...)

	arr := data.NewArrowArray(rawData, meta)
	assert.NotNil(t, arr)
	assert.IsType(t, arrow.PrimitiveTypes.Uint8, arr.DataType())
	assert.Equal(t, N, arr.Len())
	assert.Equal(t, N/2, arr.NullN())

	for i := 0; i < N; i++ {
		assert.Exactly(t, i%2 == 0, arr.IsNull(i))
		if i%2 == 1 {
			assert.Exactly(t, uint8(i), arr.(*array.Uint8).Value(i))
		}
	}
}
