// Code generated by vector_numeric.gen_test.go.tmpl. DO NOT EDIT.

package data_test

import (
	"reflect"
	"testing"

	"github.com/factset/go-drill/internal/data"
	"github.com/factset/go-drill/internal/rpc/proto/exec/shared"
	"github.com/stretchr/testify/assert"
	"google.golang.org/protobuf/proto"
)

func TestInt64Vector(t *testing.T) {
	const N = 10
	b := data.Int64Traits.CastToBytes([]int64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewInt64Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(int64(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, int64(i), vec.Get(uint(i)))
		assert.Exactly(t, int64(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableInt64Vector(t *testing.T) {
	const N = 10
	b := data.Int64Traits.CastToBytes([]int64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableInt64Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(int64(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(int64)
			*val = int64(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, int64(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestInt32Vector(t *testing.T) {
	const N = 10
	b := data.Int32Traits.CastToBytes([]int32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewInt32Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(int32(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, int32(i), vec.Get(uint(i)))
		assert.Exactly(t, int32(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableInt32Vector(t *testing.T) {
	const N = 10
	b := data.Int32Traits.CastToBytes([]int32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableInt32Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(int32(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(int32)
			*val = int32(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, int32(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestFloat64Vector(t *testing.T) {
	const N = 10
	b := data.Float64Traits.CastToBytes([]float64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewFloat64Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(float64(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, float64(i), vec.Get(uint(i)))
		assert.Exactly(t, float64(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableFloat64Vector(t *testing.T) {
	const N = 10
	b := data.Float64Traits.CastToBytes([]float64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableFloat64Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(float64(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(float64)
			*val = float64(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, float64(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestUint64Vector(t *testing.T) {
	const N = 10
	b := data.Uint64Traits.CastToBytes([]uint64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewUint64Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(uint64(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, uint64(i), vec.Get(uint(i)))
		assert.Exactly(t, uint64(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableUint64Vector(t *testing.T) {
	const N = 10
	b := data.Uint64Traits.CastToBytes([]uint64{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableUint64Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(uint64(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(uint64)
			*val = uint64(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, uint64(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestUint32Vector(t *testing.T) {
	const N = 10
	b := data.Uint32Traits.CastToBytes([]uint32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewUint32Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(uint32(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, uint32(i), vec.Get(uint(i)))
		assert.Exactly(t, uint32(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableUint32Vector(t *testing.T) {
	const N = 10
	b := data.Uint32Traits.CastToBytes([]uint32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableUint32Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(uint32(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(uint32)
			*val = uint32(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, uint32(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestFloat32Vector(t *testing.T) {
	const N = 10
	b := data.Float32Traits.CastToBytes([]float32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewFloat32Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(float32(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, float32(i), vec.Get(uint(i)))
		assert.Exactly(t, float32(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableFloat32Vector(t *testing.T) {
	const N = 10
	b := data.Float32Traits.CastToBytes([]float32{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableFloat32Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(float32(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(float32)
			*val = float32(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, float32(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestInt16Vector(t *testing.T) {
	const N = 10
	b := data.Int16Traits.CastToBytes([]int16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewInt16Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(int16(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, int16(i), vec.Get(uint(i)))
		assert.Exactly(t, int16(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableInt16Vector(t *testing.T) {
	const N = 10
	b := data.Int16Traits.CastToBytes([]int16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableInt16Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(int16(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(int16)
			*val = int16(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, int16(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestUint16Vector(t *testing.T) {
	const N = 10
	b := data.Uint16Traits.CastToBytes([]uint16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewUint16Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(uint16(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, uint16(i), vec.Get(uint(i)))
		assert.Exactly(t, uint16(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableUint16Vector(t *testing.T) {
	const N = 10
	b := data.Uint16Traits.CastToBytes([]uint16{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableUint16Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(uint16(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(uint16)
			*val = uint16(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, uint16(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestInt8Vector(t *testing.T) {
	const N = 10
	b := data.Int8Traits.CastToBytes([]int8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewInt8Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(int8(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, int8(i), vec.Get(uint(i)))
		assert.Exactly(t, int8(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableInt8Vector(t *testing.T) {
	const N = 10
	b := data.Int8Traits.CastToBytes([]int8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableInt8Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(int8(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(int8)
			*val = int8(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, int8(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}

func TestUint8Vector(t *testing.T) {
	const N = 10
	b := data.Uint8Traits.CastToBytes([]uint8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	vec := data.NewUint8Vector(b, nil)

	assert.Equal(t, reflect.TypeOf(uint8(0)), vec.Type())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Exactly(t, uint8(i), vec.Get(uint(i)))
		assert.Exactly(t, uint8(i), vec.Value(uint(i)))
	}

	assert.Same(t, &b[0], &vec.GetRawBytes()[0])
}

func TestNullableUint8Vector(t *testing.T) {
	const N = 10
	b := data.Uint8Traits.CastToBytes([]uint8{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	})

	bytemap := []byte{0, 1, 0, 1, 0, 1, 0, 1, 0, 1}
	meta := &shared.SerializedField{ValueCount: proto.Int32(10)}

	vec := data.NewNullableUint8Vector(append(bytemap, b...), meta)
	assert.Equal(t, reflect.TypeOf(uint8(0)), vec.Type())

	assert.EqualValues(t, b, vec.GetRawBytes())
	assert.EqualValues(t, bytemap, vec.GetNullBytemap())

	l, ok := vec.TypeLen()
	assert.Zero(t, l)
	assert.False(t, ok)
	assert.Equal(t, N, vec.Len())

	for i := 0; i < N; i++ {
		assert.Equal(t, i%2 == 0, vec.IsNull(uint(i)))
		if i%2 == 1 {
			val := new(uint8)
			*val = uint8(i)

			assert.Exactly(t, val, vec.Get(uint(i)))
			assert.Exactly(t, uint8(i), vec.Value(uint(i)))
		} else {
			assert.Nil(t, vec.Get(uint(i)))
			assert.Nil(t, vec.Value(uint(i)))
		}
	}
}
